// To compile and run this program using jacc and Sun's JDK:
//
//    jacc simpleCalc.jacc
//    javac Calc.java CalcTokens.java
//    java  Calc
//     ... enter arithmetic expressions ... hit EOF to terminate
//
%{
    import java.io.*;
    import java.util.*;
%}

%class     CuteMorphoParser
%interface Parser
%semantic  Object: yylval
%get       token
%next      yylex()

%token <String> NAME
%token <String> LITERAL
%token FUNC VAR IF ELSE WHILE RETURN  EQUALS 
%token OPNAME1 OPNAME2 OPNAME3 OR AND NOT
// %type <Object[]> funcdecl
// %type <Vector<Object>> bodyexprs


%%

start:  
    bodyexprs
    ;

bodyexprs:  
    bodyexprs expr ';'
    | bodyexprs vardecl ';'
    | /* EMPTY */
    ;

vardecl:
    VAR NAME EQUALS expr
    ;

expr:   
    RETURN expr
    | NAME EQUALS expr
    | orexpr
    ;

orexpr:
    orexpr OR andexpr
    | andexpr
    ;

andexpr:
    andexpr AND notexpr
    | notexpr
    ;

notexpr:
    NOT notexpr
    | binopexpr
    ;

binopexpr:
    binopexpr OPNAME1 smallexpr
    | smallexpr
    ;
    
smallexpr:
    OPNAME1 smallexpr
    | '(' expr ')'
    | LITERAL
    | NAME
    | NAME '(' args ')'
    | FUNC '(' ')' body
    ;
    /*WHILE*/
    /*IF*/

args:
    /* empty */
    | arglist
    ;

arglist:
    arglist ',' expr
    | expr
    ;

body:   
    '{' bodyexprs '}'
    ;

%%
    private CuteMorphoLexer lexer;

    int token;
    int last_token_read;  
    public String yylval;

    int yylex () {
        int yyl_return = -1;
        try {    
            yylval = null;
            System.out.println(token); 
            token = lexer.yylex();
            yylval = "This is string";
        } catch (IOException e) {
            System.err.println("IO error :"+e);
        }
        return token;
    }

    private void yyerror(String msg) {
        System.out.println("ERROR: " + msg);
        System.exit(1);
    }

    public CuteMorphoParser(Reader r) {
        lexer = new CuteMorphoLexer(r, this);
    }