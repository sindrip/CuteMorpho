// To compile and run this program using jacc and Sun's JDK:
//
//    jacc simpleCalc.jacc
//    javac Calc.java CalcTokens.java
//    java  Calc
//     ... enter arithmetic expressions ... hit EOF to terminate
//
%{
    import java.io.*;
    import java.util.*;
    import ast.*;
%}

%class     CuteMorphoParser
%interface Parser
%semantic  Node: yylval
%get       token
%next      yylex()

%token <StringContainerNode> NAME
%token <StringContainerNode> LITERAL
%token FUNC VAR IF ELSE WHILE RETURN  EQUALS 
%token OPNAME1 OPNAME2 OPNAME3 OR AND NOT
%type <FuncNode> funcdecl
%type <RootNode> bodyexprs


%%

start:  bodyexprs { this.program = $1; }
        ;

bodyexprs:  bodyexprs funcdecl ';' { $1.add($2); $$=$1; }
            | bodyexprs VAR NAME EQUALS expr ';' { $$ = new VarNode((StringContainerNode)$5); }
            | /* EMPTY */ { $$ = new RootNode();}
            ;

funcdecl:   FUNC NAME '(' ')' body { $$ = new FuncNode($2); }
            ;

body:   '{' bodyexprs '}'
        ;

expr:   LITERAL { $$ = $1; System.out.println($$); }
    ;


%%
    private CuteMorphoLexer lexer;

    int token;
    int last_token_read;  
    RootNode program;
    public StringContainerNode yylval;
    public String yylvals;

    public RootNode getProgram() {
        return this.program;
    }

    int yylex () {
        int yyl_return = -1;
        try {    
            yylval = null;
            System.out.println(token); 
            token = lexer.yylex();
            yylval = new StringContainerNode(yylvals);
        } catch (IOException e) {
            System.err.println("IO error :"+e);
        }
        return token;
    }

    private void yyerror(String msg) {
        System.out.println("ERROR: " + msg);
        System.exit(1);
    }

    public CuteMorphoParser(Reader r) {
        lexer = new CuteMorphoLexer(r, this);
    }